% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inlasloo.R
\name{inlasloo.fun}
\alias{inlasloo.fun}
\title{A function to run a spatial leave-one-out cross-validation in R using INLA.}
\usage{
inlasloo.fun(dataframe, long, lat, y, ss, rad, modform, family, mesh,
  ntrials = NULL, int.strategy = "eb", alpha = 0.05, mae = FALSE,
  ds = FALSE, sqroot = FALSE, ...)
}
\arguments{
\item{dataframe}{= dataframe including the variables to be used}

\item{long}{= Character string giving the name of the longitude variable}

\item{lat}{= Character string giving the name of the latitude variable}

\item{y}{= Character string giving the names of the response}

\item{ss}{= Numeric value giving the sample size to process (number of SLOO runs)}

\item{rad}{= Numeric value giving the radius for the spatial buffer around left-out point's location}

\item{modform}{= Formula or list of Formula for the model or models, respectively in INLA format}

\item{family}{= Character string or list of Character string giving the family or families, respectively of the response in INLA format}

\item{mesh}{= inla.mesh object, consisting in triangle mesh to be defined using INLA.}

\item{ntrials}{= Numeric value (1,2,...) setting the number of trials for a Binomial family}

\item{int.strategy}{= Character string giving INLA integration strategy}

\item{alpha}{= Numeric value (0,...,1) giving the threshold for computing confidence intervals (1-alpha) of rmse and mae estimation}

\item{mae}{= If TRUE, compute the mean absolute error (mae) and the root mean square error (rmse). If FALSE, compute the rmse only.}

\item{ds}{= If TRUE, compute the Dawid-Sebastiani score (ds). If FALSE, does not compute ds.}

\item{sqroot}{= If TRUE, compute the square root of the observed and predicted values to generate the rmse and/or mae. 
If FALSE, the rmse and/or mae are computed without transformation of the data.}

\item{...}{other arguments passed to methods}
}
\description{
This function will apply a spatial leave-one-out cross-validation (SLOO-CV) of one or several models running on INLA.
The function requires a dataframe that includes a response, coordinates (longitude, latidude). 
Covariates can be inluced as well in the dataframe. Furthermore, the user needs to provide a radius
around which points will be removed during the SLOO-CV process. The number of iterations needs to be provided as well. 
Also the user needs to provide INLA inputs, including: formula, family (and ntrials for Binomial), and mesh
In addition, one can provide further INLA specifications, such as int.strategy='eb'.
SLOO-CV computes the root mean square error (rmse) with a tolerance for confidence interval defined by the user. 
In option, other scores can be computed, such as the mean absolute error, dawid-sebastiani or using square root of the data.
}
\examples{
 \dontrun{
 require(INLA)
 require(sp)
 require(grDevices)
 
 # generate a dataframe and INLA output for the function
 set.seed(10)
 coords <- data.frame(long = c(rnorm(70), rnorm(30, 3)), lat = rnorm(100))
 PA <- rep(c(0, 1), each = 50)
 x <- data.frame(x1 = rnorm(100),x2 = c(rnorm(70), rnorm(30, 2)))# x1 no relat., x2 pos. relat.
 dataf1 <- sp::SpatialPointsDataFrame(coords = coords, data = data.frame(y = PA, x))
 mesh <- INLA::inla.mesh.2d(loc = sp::coordinates(dataf1),max.edge = c(3, 3),cutoff = 1.3)
 spde <- INLA::inla.spde2.matern(mesh, alpha=2)#SPDE model is defined
 A <- INLA::inla.spde.make.A(mesh, loc = sp::coordinates(dataf1))#projector matrix
 dataframe <- data.frame(dataf1) #generate dataframe with response and covariate
 modform<-stats::as.formula(paste('y ~ -1+ x1 + x2 + y.intercept + f(spatial.field, model=spde)'))
 stk <- INLA::inla.stack(data=list(y=dataframe$y),A=list(A, 1),
 effects=list(list(spatial.field=1:spde$n.spde),
 list(y.intercept=rep(1,length(dataframe$y)),covariate=dataframe[c(-1)])),tag='est')
 out <- INLA::inla(modform, family='normal',Ntrials = 1, data=INLA::inla.stack.data(stk, spde=spde),
                   control.predictor = list(A=INLA::inla.stack.A(stk),link=1),
                   control.compute = list( config=TRUE),control.inla = list(int.strategy='eb'))
 out.field <- INLA::inla.spde2.result(out,'spatial.field', spde, do.transf=TRUE)
 range.out <- INLA::inla.emarginal(function(x) x, out.field$marginals.range.nominal[[1]])
 
 # parameters for the SLOO process
 ss <- 11#sample size to process (number of SLOO runs)
 rad <- range.out*0.15#define the radius of the spatial buffer surrounding the removed point
 mesh <- mesh#use the mesh of the model
 dataframe <- dataframe#dataframe with response 'y' and covariates 'x1', 'x2'
 dataframe$y <- round(runif(length(dataframe$y), 0, 12))#create positive discrete response
 modform <- stats::as.formula(paste('y ~ -1+ y.intercept + x1 + f(spatial.field, model=spde)'))
 family <- list('gamma')#one model
 ntrials <- round(max(dataframe$y,na.rm=TRUE))# for Binomial family
 alpha <- 0.05#rmse and mae confidence intervals (1-alpha)
 
 # run the function
 inlasloo.fun(dataframe=dataframe, long='x_coord', lat='y_coord',y= 'y', ss=ss, rad=rad, 
 ntrials=ntrials,modform=modform,mesh=mesh,family=family,alpha=0.05,mae=TRUE,ds=TRUE,sqroot=FALSE)
  
 # SLOO function with one model formula (Binomial) and linear terms
 sloo1<-inlasloo.fun(dataframe=dataframe, long='x_coord', lat='y_coord', y='y', ss=1, rad=0.1, 
 ntrials=5,modform='y ~ -1+ x1 + x2 + y.intercept + f(spatial.field, model=spde)',mesh=mesh,
 family='binomial',alpha=0.05,mae=TRUE,ds=FALSE,sqroot=FALSE)
 
 # SLOO function with two families (Binomial and Poisson) and linear terms
 sloo2<-inlasloo.fun(dataframe=dataframe, long='x_coord', lat='y_coord', y='y', ss=1, rad=0.1,
  ntrials=5,modform='y ~ -1+ x1 + x2 + y.intercept + f(spatial.field, model=spde)',mesh=mesh,
 family=list('binomial','poisson'),alpha=0.05,mae=TRUE,ds=FALSE,sqroot=FALSE)
 
 # SLOO function with one family (Binomial) and two model formulas
 sloo2<-inlasloo.fun(dataframe=dataframe, long='x_coord', lat='y_coord', y='y', ss=1,
  rad=0.1, ntrials=5,modform=list('y ~ -1+ y.intercept + f(spatial.field, model=spde)',
 'y ~ -1+ x1 + x2 + y.intercept + f(spatial.field, model=spde)'),
 mesh=mesh,family='binomial',alpha=0.05,mae=TRUE,ds=FALSE,sqroot=FALSE)
 }
 
}
